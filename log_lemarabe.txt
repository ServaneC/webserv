[20/6]
    - Chdir avant execve !! Avant chaque requete je chdir pour me retrouver
a la racine du serveur et execve est lancé depuis le bon path (plus besoin
du #define PATH). Pour l'instant je chdir dans setPathQuery(), c'est ptet
pas le lieu le plus pertinent mais j'attend de voir une fois que j'aurais
rajouté la gestion de root locales (la c'est que root general du serveur)
--------------------------------------------------------------------------
[15/6]
    - Parsing de root : je recupere la racine generale du serveur et aussi
les racines dans les locations.
--------------------------------------------------------------------------
[11/6]
    - Locations : avec le cerveau moins en bouillie aujourd'hui j'avais des
idées concernant la marche a suivre donc je suis en train de parser/stocker
les accepted_methods.
    - Creation d'une classe Location comprenant le _path, la _conf et les
_accepted_methods. Du coup les _routes c'est plus une map<str, str> mais
une std::list<Location>. Mais j'ai pas fini la fonction de parsing...
    - J'avais envie de faire un switch parce que c'est super gracieux je
trouve, du coup je convertis les methodes en codes (0, 1, 2, 3 (mais c'est
des define tkt)), pour l'instant il est ecrit mais commenté parce que je
sais pas trop quelles sont les instructions a donner en fct de la methode. 
--------------------------------------------------------------------------
[10/6]
    - Révision architecture : les fonctions de parsing sont passees dans
parsing.cpp qui est accompagné de parsing.hpp contenant la definition de
l'union IPA_t.
    - Locations : j'arrive pas du tout a trouver de liste exhaustive des
champs possibles donc ca me parait chaud et/ou inutile d'initialiser des
champs dans une struct. Et en plus a priori on est censé pouvoir emboiter
des locations dans des locations, donc faudrait que je revoie le parsing.
Du coup j'imagine qu'on ne prend pas les champs "fastcgi_pass" ?? je
comprend pas assez comment marche un cgi pour prendre une decision...
--------------------------------------------------------------------------
[8/06]
    - Gestion des lignes commentées ok
    - J'ai rajouté des exceptions dans le parsing (si il manque des infos,
si les nombres donnés sont invalides, etc). Pour l'instant ca n'arrete pas
le programme, juste le parsing du serveur en cours : si il y a une erreur
dans le premier serveur, il va quand meme essayer de configurer le suivant,
je sais pas si c'est la bonne facon de gerer.
    - Parsing de l'adresse IP : je mets tout dans un union de ma creation
(IPA_t) qui contient un unsigned char[4] et un unsigned int et vu qu'ils
partagent la meme adresse, quand je demande le uint, il interprete les 4
blocs comme une adresse IP sur 32 bits.
    - Parsing des locations : pour l'instant j'ai utilisé la map<string,
string> _routes que t'avais créé, je recupere le path concerné comme etant
la clé et le scope des instructions comme etant le contenu.

##########################################
##          NOTES ON WEBSERV            ##
##########################################

"Because you won’t call the CGI directly use the full path as PATH_INFO"
"the cgi should be run in the correct directory for relativ path file access"

--> [XSI] Structure used by kernel to store most addresses.
    struct sockaddr {
        __uint8_t       sa_len;         /* total length */
        sa_family_t     sa_family;      /* [XSI] address family */
        char            sa_data[14];    /* [XSI] addr value (actually larger) */
    };
--> Socket address, internet style.
    struct sockaddr_in {
        __uint8_t       sin_len;
        sa_family_t     sin_family;
        in_port_t       sin_port;
        struct  in_addr sin_addr;    // == __uint32_t
        char            sin_zero[8];
    };
--> Structure used to store a set of fd.
    typedef struct fd_set {
        __int32_t       fds_bits[__DARWIN_howmany(__DARWIN_FD_SETSIZE, __DARWIN_NFDBITS)];
    } fd_set;


FORMAT FOR HTTP REQUESTS
    1) A Request-line
        Method <space> Request-URI <space> HTTP-Version <CRLF>
    2) Zero or more header fields (General|Request|Entity) followed by CRLF
        Accept-Charset // Accept-Encoding // Accept-Language // Authorization // Expect //
        From // Host // If-Match // If-Modified-Since // If-None-Match // If-Range //
        If-Unmodified-Since // Max-Forwards // Proxy-Authorization // Range // Referer //
        TE // User-Agent
    3) An empty line indicating the end of the header fields (= nothing preceding CRLF) 
    4) Optionally a message-body

Replace memset by std::fill ? 
Maybe don't initialize header fields and just accept any that is given. 

