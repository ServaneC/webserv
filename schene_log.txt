Webserv 
(12/03/2021)

Simplification des RFC: https://docs.google.com/document/d/1_hyiqjK-wjBFPsQX040qw0_vOuAsTEjliU7gOI8rHkk/edit?usp=sharing
Fonctions: https://docs.google.com/document/d/1kAKD5ucdXaoeX5MRfoqCjVR78kADcq030BgyIGOLoUk/edit?usp=sharing

La libft n'est plus autorisÃ© !
Authorized functions: everything in c++98
htons, htonl, ntohs, ntohl, select, poll, epoll, kqueue, socket, accept, listen, send, recv, bind, connect, inet_addr, setsockopt, getsockname, fcntl

HTTP Methods :

Minimum in a webserv:
-> GET
-> POST
-> DELETE

Vm = little endian

- [x] Lire les RFC + prendre des notes / surligner 
- [x] Faire des test avec nginx et telnet 

25/03/2021
curl -I example.com	=> Renvoi le header HTTP comme un webserver (mais marche si Nginx ne run pas)
curl -I 'localhost'		=> ne marche que si Nginx run 
âœ… Makefile fait + libft dans le dossier
-> prise de notes sur les nouvelles fonctions 

29/03/2021
-> crÃ©ation dâ€™une classe server
-> essai de faire un server fonctionnel trÃ¨s trÃ¨s simplifiÃ©
	> class Server
	> class Request

30/03/2021
- [x] Trier les req. Header / response Header 
- [x] Faire un map stockant toutes les valeurs des request header field possible
- [x] Parse request (manque le message body) -> pas utile pour GET
-> dÃ©but du setup du CGI (env)

01/04/2021
- [x] Faire un simple cgi qui ouvre et renvoi un simple fichier html
- [x] Faire un .hpp avec tout les includes commun = plus propre

02/03/2021
- [x] Envoyer la rÃ©ponse au socket 
- [x] Faire marcher dans la vm !!!
-> safari dit que la demande est en HTPP/0.9 ?!
-> jâ€™ai Ã©crit les header fields de la rÃ©ponse sur cout au lieu du socket ğŸ™„
- [x] pouvoir la visualiser dans le moteur de recherche (mac + VM ğŸ‰)
-> to format the date we have gettimeofday(), strftime() and strptime()-> we should probably ignore  strptime()
- [x] GÃ©rer date avec les fonctions appropriÃ©s â€¼ï¸ Utilisation de gmtime (fonction apparement non autorisÃ©)

05/04/2021
- [x] Mettre la request dans un fichier a part et le client lit le fichier puis envoie la request (= plus facilement modifiable)
- [x] GÃ©rer le last-modified
- [x] Faire une fonction pour formater les dates 
â€”> sur la vm la request arrives vide au server 
- [x] Faire marcher dans la vm ! (Câ€™est chelou quand mÃªme)

06/04/2021
- [x] Mettre sur github
- [x] Faire un page index.html
- [x] GÃ©rer les target avec â€˜/â€˜ (absolut path)

07/04/2021
- [x] Faire un test simple faisant appelle a php-cgi 
- [x] RÃ©ussir a appeler php-cgi et avoir un retour avec execve
â€”> ca marche pas de ouf, la rÃ©ponse nâ€™arrives pas, ca bloque apparement a un endroit
(Jâ€™avais oubliÃ© dâ€™appeler la fonctions execCGI ğŸ¤¦ğŸ»â€â™€ï¸ )


08/04/2021
- [x] Trouver un cgi qui marche pour autre chose que php et surtout pour mac  => CGI dans les ressources !!!
- [x] Tester les cgi des ressources 
-> le cgi_tester marche avec execve mais ne renvois rien 
-> le cgi tourne dans le videâ€¦ ğŸ’€
ğŸ‘‰ on se re-concentre sur php-cgi
- [x] Faire marcher php-cgi avec notre WebServ
-> Ã§a affiche aussi le header field dans le web but on verra ca plus tard !
ğŸ‘‰ Plus le choix faut rÃ©ussir a faire marcher cgi_tester !
->execve crash avec cgi_tester 
- [x] Faire marcher cgi_tester avec execve (meme si retour pas bon)
ğŸ¤¦ğŸ»â€â™€ï¸ a.out Ã©tait dans srcs et donc pas dans le meme repo que cgi_tester et index.html
- [x] Comprendre comment bien appeler cgi_tester
ğŸ˜• Il nâ€™y a pas de body dans la rÃ©ponse du cgiâ€¦

09/04/21
- [x] Essayer de passer le file en argument du cgi -> voir si le body apparait
-> le body apparait pas â€¦
- [x] Retrouver ce qui marchait avec php-cgi parce que la ca marche plus lol
ğŸ¤¦ğŸ»â€â™€ï¸ Jâ€™avais mis HEAD en mÃ©thode dans le test.cpp donc forcement y avait plus le body 
ğŸ˜© Le cgi_tester ne renvois toujours pas de body !
- [x] Bosser sur le repo git !
-> on verra le body plus tard, je tourne en rond !
-> php-cgi renvoie en header field puis un \n et le body
- [x] Parser le header field renvoyÃ© par le cgi
	-> ca marche pour le header renvoyÃ© par cgi_tester (sans body du coup) mais ca diminue le fichier dans la vm avec php-cgi
	-> il y avais un souci car php-cgi renvoi un header â€˜Content-typeâ€™ au lieu de â€˜Content-Typeâ€™  (jâ€™ai rÃ©gler le souci de maniÃ¨re un peu moche)
    - [x] Arriver a arrÃªter le parsing a la fin des headers fields. 
		-> jâ€™essayais de trouver un \n en dÃ©but de ligne pour arrÃªter mais câ€™Ã©tait un \r quâ€™il y avait (CRLF = \r\n)
	ğŸ‘‰ Ca marche aussi avec un 404 (on rÃ©cupÃ¨re le bon status)

12/04/2021
-> ajout des CRLF (\r\n)  au lieu de juste \n dans la rÃ©ponse HTTP
- [x] RÃ©organiser toutes les fonctions => diviser les gros blocs
	-> Jâ€™ai crÃ©er une fonction send_response (qui imprime les header_fields dans une boucle)
	=> rÃ©organisation faite pour Response
- [x] Deux \n entre header et body dans la response ? -> le \n est deja dans le body
- [x] Utilisation de select pour read

14/04/2021
-> Jâ€™ai mis tout les .hpp dans un dossier include dans les srcs
-> Jâ€™ai fait un dossier test_dir avec tout les fichier test = câ€™est un peu moins le bordel 
â€¼ï¸ T=ï¿½ 1 fois sur deux en fin de rÃ©ponse ?
	-> Jâ€™ai bien terminer le buf avec un 0 au lieu de juste le ft_memcpy
- [x] GÃ©rer les leak avec -fsanitize=address
    - [x] Memory access after free dans le response destructor
	-> juste un clear au lieu dans erase en boucle + clear
- [x] Parse la request au CRLF et pas juste \n
- [x] Parse url of type ->  http://localhost:80/
    - [x] AmÃ©liorer le parsing de la request line
	-> ajout dâ€™une fonction ParseRequestLine
=> PUSH GitHub

15/04/2021
-> RÃ©glage du dÃ©calage horaire (+ 2h)		 / / je viens du futur, câ€™etait inutile !
- [x] GÃ©rer les OWS dans le parsing des header field de la request


20/04/2021
- [x] Modifier ce quâ€™il faut  car mnt on peut utiliserÂ  ctime  et cstring
	-> time() au lieu de gettimeofday() = +simple (jâ€™ai enlever le rÃ©glage du dÃ©calage horaire car GMT nâ€™est pas sensÃ© Ãªtre lâ€™heure exacte en France)
	-> gmtime() est mnt autorisÃ©
    - [x] utiliser cstring plutÃ´t que la libft
- [x] Utiliser des ref sur string dans les getter
	-> jâ€™ai mis search_header en private (dans response)
- [x] Voir pour utiliser getline() au lieu de gnl
	-> ca semble compliquÃ© il faudrait ouvrir le file avec fstream mais câ€™est pas autorisÃ©â€¦
	-> peut Ãªtre lire tout le file dans un buf puis crÃ©er une stream sur le buf ? ->semble pas trÃ¨s optimal
	-> voir pour lire le socket dans server.cpp et ensuite lâ€™envoyÃ© a request.cpp qui parsera le tout -> on pourra se dÃ©barrasser de gnl
	=> on continue avec gnl pour le moment a voir si ils autorisent fstream a lâ€™avenirâ€¦
- [x] Mieux comprendre le conf file et ce quâ€™il fait exactement

21/04/2021
ğŸ‘‰ avec php-cgi ubuntu_tester renvoi Â«Â FATAL ERROR ON LAST TEST: unexpected EOFÂ Â» au premier test
	-> pourquoi ?!
	-> overflow dans gnl apres plusieur lancement du tester  // on verra plus tard
    - [x] ajouter un CRLF a la fin du body. // je viens du futur et fallais pas faire ca 
	ğŸ‰ Passage du premier test avec php-cgi (le pb venais juste du CRLF)
	â€”> je passe apparement le test POST (jâ€™ai fait en sorte quâ€™il renvoi une erreur mais de maniere tres moche pour le moment) 
		-> ca marche pas tout le tempsâ€¦
- [x] faire une GET method pas ouf et voir si on passe le premier test
ğŸ‘‰ Jâ€™ai fait une fonction  execGET mais elle semble pas parfaite et a retravaillerâ€¦
- [x] mieux gÃ©rer les CRLF entre les header et le body et a la fin si y a pas de body.
ğŸ“ Jâ€™aurais apparement eu raison au dÃ©but en crÃ©ant moi meme la reponse a GET, je crois que le CGI est a utiliser seulement pour certaine mÃ©thodes
Sur mac: 2eme test
	Test POST http://localhost:8080/ with a size of 0
	2021/04/21 20:02:11 Unsolicited response received on idle HTTP channel starting with "\r\n"; err=<nil>
âœ… Ca marche ! ğŸ‘‰ il ne faut pas mettre de CRLF apres le message-body (juste entre header et body/fin)
Pour le moment GET ignore le path et ouvre juste index.html

22/04/2021
- [x] faire ouvrir le bon path / renvoyer le bon message dâ€™erreur pour GET
Abort apres plusieur refresh et un client en not found 
	âœ… RÃ©solu: crÃ©ation dâ€™une fonction free_buf appelle dans response (a revoir pour quelque chose de plus propre)
- [x] pb avec last modified (indique 1970)
	ğŸ‘‰ Ajout dâ€™un getter last-modified dans myCGI

23/04/2021
Tester dans la VM:
-> probleme de parsing, un buf doit etre mal vidÃ© ou autreâ€¦ ca fait des trucs chelou
-> peut etre une erreur avec write ? (write: broken pipe)
ğŸ‘‰ Câ€™est chelou le premier test marche mais les autres passe une fois sur 3
Tester mac:
âœ… Les trois premiers test passe a chaque fois sans pb (câ€™est normal jâ€™ai pas gÃ©rÃ© la rÃ©ponse du 4Ã¨me)
â€¼ï¸ Le 2Ã¨me et 3Ã¨me je renvois juste lâ€™erreur quâ€™il veut cÂ â€˜est pas pro et ca passerais pas câ€™est complÃ¨tement a revoir 

ğŸ¤¦ğŸ»â€â™€ï¸ Nouveau problÃ¨me le tester bloque a POST (2eme test)
-> les meme test en passant par client ne bloques pas
ğŸ™„ RÃ©gler jâ€™avais oubliÃ© de close le socket (je lâ€™avais commentÃ© pour tester un truc vite fait)

- [x] gÃ©rer le body dans request
	-> câ€™est gÃ©rÃ© faudrait juste bien check quâ€™il y a le CRLF avant et ca sera parfait 
	+ faire une ( ou 2 ) fonction(s) en plus pour alleger parseRequest()
ğŸ‘‰ essayer de passer les trois premiers test sur la VM
	-> POST =  read: connection reset by peer / write: broken pipe
	-> ca vient peut etre de gnl ğŸ¤”
	-> des fois tout passe et des fois ca bloque a POSTâ€¦ ğŸ˜¡


27/04/2021
- [x] mettre dans une fonction a part le parsing des headers field dans request
	+ ajout dâ€™une fonction free_null_line
- [x] essayer de crÃ©er un container docker pour tester avec nginx
	-> jâ€™ai juste lancer un container sur la vm et jâ€™ai pu envoyer un GET mais faudrait faire bcppppp plus de test
- [x] amÃ©liorer le check si CRLF dans request 
- [x] â€˜use the parsed data to determine if a message body is expectedâ€™ ğŸ‘‰ Le parsing du body est peut Ãªtre a revoir 
	ğŸ‘‰ Content-Lenght ou transfer encoding = message body
	âœ… C â€˜est fait mais pas testÃ©
ğŸ¤¦ğŸ»â€â™€ï¸ Leaks gnl  avec le testeur dans la vm (mais rien sur mac) (dans parseRequest)
- [x] bien check la request et renvoyÃ© erreur si incorrect
    - [x] renvoyÃ© la bonne rÃ©ponse si pas de CRLF (bad Request je crois) -> actuellement câ€™est juste un perror tout pourri et un exit
		âœ…  + si space entre field-name et colon = renvoi un 400 bad request
		ğŸ‘‰ peut Ãªtre a revoir pour mieux gÃ©rer mais ca marche 

28/04/2021
- [x] rÃ©soudre la leak dans parse request (sur vm)
	ğŸ¤·ğŸ»â€â™€ï¸ Je la retrouve pas, jâ€™ai du la rÃ©soudre sans faire exprÃ¨s
ğŸ‘‰ Pour le moment les test bug parfais dans la vm et parfois passent, ca vient peut etre du select ? Je verrais plus tardâ€¦
	ğŸ‘‰ En tout cas les trois premier passent a chaque fois sans pb sur mac
- [x] mieux gÃ©rer les erreurs possible dans le parsing de la request line
    - [x] accepter tout les ws pas just sp comme sÃ©parateur 
		ğŸ‘‰MAY instead parse on whitespace-delimited word boundaries 
		ğŸ‘‰ Câ€™est pas obligatoire a gÃ©rÃ© âŒ
    - [x] renvoyer un bad request si plus que 1 ws entre item

30/04/2021
ğŸ‘‰ CrÃ©ation de la classe config qui serviras a mettres les infos du conf file
    - [x] lire le file dans une string

03/05/2021
pistes pour le parsing:
	-> split tout les server {} puis les traiter chacun dans une autre classe
	-> Avoir une classe config de base avec un vector de pointeur sur les diffÃ©rents serveurs
	-> Dans la classe confServer:
		- server_name
		- map des routes -> peut etres il faut une class config pour les routes aussi (pour stocker les accepteds method et autre
			-> un map<string, ConfigRoute> peut-Ãªtre avec dans configRoute
				- root =  a directory or a file from where the file should be search 
				- Vector ou list des mÃ©thodes acceptÃ©s
				- default file to answer if the request is a directory 
				- client body size
		-  bool pour  Â«Â turn on or off directory listÂ Â»		- limit client body size
		- map avec les error pages 
		- host:port

04/05/2021
- [ ] Comprendre ce que fait chaque mÃ©thodes -> Ã©crire une explication avec exemple pour chaque 
- [x] tester la mÃ©thode DELETE avec le cgi_tester -> bad request

06/05/2021
- [x] modifier le client pour quâ€™il ajoute le CRLF entre les headers et le body/la fin
	-> câ€™est fait mais mnt le serveur capte plus rien 
    - [x] re tester avec le tester -> Ca marche âœ…
	-> le serveur ne lit pas la request en entierâ€¦ pourquoi ?
	-> Je suis revenu a comme avant faut que jâ€™essaye autre chose
	-> jâ€™ai tentÃ© autre chose mais mnt jâ€™ai un segfault dans le parserequest ğŸ¤¦ğŸ»â€â™€ï¸
	-> Abandon â€¦
- [x] Au lieu de check si CRLF entre header et body -> check si CRLF ou juste LF
- [x] retester DELETE avec cgi_tester -> ca marche pas jâ€™ai peut etre pas compris DELETE
- [x] tester dans la vm avec php-cgi
	-> la rÃ©ponse a un body alors quâ€™elle ne devrait pas 

â€¼ï¸ On dirait que le parsing du header du cgi ne marche plus ğŸ¤”
    - [x] revoir la fonction parse_cgi_buf()
	âœ… RÃ©solu -> je returnais si le buf nâ€™Ã©tais pas empty donc forcÃ©ment ca returnais a chaque foisâ€¦ ğŸ™„

01/06/2021 (NEW SUBJECT !)
- [x] comprendre ce qu'est 'poll' => variation de select ( a voir si c'est mieux)
- [x] modifier le code afin de ne plus utiliser la libft
	-> ft_isspace -> isspace
	-> ! PB: gnl n'est plus utilisable, il faut donc revoir tout les appels a gnl
	-> il faut surement remplacer par l'utilisation des streams
	-> pb: stream ne marche pas sur les fd, il faut probablement lire toutes la requete et ensuite la parser

03/06/2021 
!! ERREUR "In select: Bad file descriptor" sur le mac de l'ecole avec localhost:8080" dans google chrome
	-> en revanche sa marche avec safari... 
- [x] parser la request sans utiliser gnl
	-> je lis la request avec recv 
	-> il faut mnt la transformer en string puis la parser. 
		- [x] recu et transformer en string 
		!! pb: les request s'empilent au lieu de s'effacer => clear a la fin de parseRequest
		- [x] parser la request
		âœ… Ã‡a marche comme avec gnl !! 
- [x] enlever la libft
	-> pb avec itoa dans response (j'ai commenter en attendant de trouver mieux)
	-> pb avec strdup dans myCGI (env_to_char_array), j'ai fait un mini strdup pas ouf dans la fonction


04/06/2021 
- [x] tester dans la vm -> Ã§a marche tres bien
- [x] voir pour remplacer ou faire autrement pour itoa
	-> creation de la foncton itoa_cpp qui utilise une stream
- [x] modifier le env to char array -> en fait c'est pas si mal
- [>] remplacer select par poll
	-> poll est plus performant que select (et il a l'air plus simple a comprendre)
	-> epoll pourrait aussi Ãªtre  interessant mais c'est specifique a linux
	=> A faire apres le parsing du conf file quandd on aura plusieurs server a gÃ©rer
- [x] faire un conf file pour ensuite le parser -> webserv.conf

07/06/2021 
-> j'ai modifiÃ© + bouger client.cpp (parce que en vrai il avait rien a faire dans les srcs) => directory client
-> le cgi est php-cgi et marche aussi sur mac 
	-> j'ai testÃ© avec GET ca marche nickel
		=> Du coup j'ai supprimÃ© la fonction execGET
	-> j'ai fait quelque test pour POST mais je comprend pas grand chose et du coup ca marche pas
	-> j'ai l'impression que quelque soit la mÃ©thode ca repond comme un GET
LEILA:
	=> modification de config et debut du parsing du conf file
	=> modif dans main -> appel a config et non Server 


08/06/2021 	
(dire a leila d'ecrire dans log / se faire un log a elle)
-> voir comment gere les locations (maybe faire une classe / struct pour stocker les infos)
	=> class is better bc we are in C++
-> verifier ce qu'a fait leila puis merge
	!! pas de merge tant que c'est pas fonctionnel
	-> revoir completement start_server
-> bon alors j'ai modifie plein de trucs et ca marche pas de ouf ca arrive a repondre a une requete avant de abort...
=> je bosse (enfin) sur ma branche git je peux donc faire toutes les modifs que je veux tranquillou
-> il va surement falloir changer de CGI parceque php-cgi marche pas sur les macs de l'ecole 
	=> ou peut etre qu'il faut mettre l'executable php-cgi dans les sources ? âœ…
-> ca marche exactement comme avant avec un seul server dans le conf file
	-> la gestion de plusieurs serveur est donc a revoir 
	-> en profiter pour remplacer select par poll
		=> poll est trop prise de tete et ca marche pas 
->pb avec les dates dans reponses (last modified a revoir)
	-> comme on passe par le cgi on a pas direct acces au fichier pour faire un fstat
		=> On oublie Last-Modified pour le moment

10/06/2021 	
-> il faut absolument merge a un moment les branches vers master sinon ca va devenir un casse tÃªte !
	a faire avant:
		-> reussir a bien gerer plusieurs "server"
			- bon j'ai retentÃ© de remplacer select par poll mais ca fait que bloquer donc je pense completement abbandonne cette piste
âœ… Tout est merge ! bon par contre j'ai quelque soucis pour acceder aux adresse ip autre que localhost:8081 avec le webserv.conf de leila...
-> l'executable de php-cgi ne suffit pas a le faire marcher quand php n'est pas installÃ© sur un ordi ...
	-> On va surement etre oblige de demander a installer php

11/06/2021
-> Il y a 2 champs Content-Type dans le header de reponse -> le compare etait mal fait mais c'est regle 
	-> header 'X-Powered-By'  ? _> c'est un header non standard qu'il est recommande d'enlever, j'ai rajouter un if qui ne stocke pas le header si il commence par 'X'
-> le CGI est mnt appelÃ© avec le file en argument (comme demandÃ© dans le sujet mais je sais pas ce que ca change)
-> reussir a accÃ©der a un fichier autre que index.html avec le cgi
	-> on peut mais a chaque lancement de webserv on ne peut plus changer le path du fichier auquel on veut accÃ©der, pourquoi ???
-> reussir a lire le body d'une request
	âœ… Il fallait parser le header, trouver Content-Lenght puis recv en boucle jusqu'a recevoir le body !
-> trouver comment passer les infos du body au cgi !!!

13/06/2021
-> il audrait merge aujourd'hui (max demain), avant j'aimerais bien:
	(au moins un des 4)
	âœ… -> reussir a acceder a differentes pages
		- je pense que c'est lie a un buf/ une string qui ne se renouvelle pas
			- l'heure change bien dans Date de response
			-> remplacer le buf std:string en char * dans response => revoir tout le parsing du buf !
			-> j'ai fait plein de modif et au final j'ai garder la forme std::string (qu'il faudra peut etre modifier plus tard) et...
			=> Ã‡a marche !!!! on peut acceder a plein de page difÃ©rentes avec un seul lancement de webserv ğŸ‰
-> avant de push + merge, tout tester surla vm ! âœ…
-> ameliorer la gestion des 400 bad request (y a un segfault actuellement) -> plus de segfault
	- renvoyer 405 method not allowed si autre que methode autorise
	
14/06/2021
-> reussir une request POST
	ğŸ‰ Ca marche avec le formulaire HTML dans index ! (fallait juste faire un write sur stdin avant le fork)
	!! Ca marche une seule fois -> surement encore un pb de buf qui se renouvelle pas ?
		âœ… C'etait bien ca le pb j'ai ajoutÃ© un clear avant de lire le body dans Request.
-> reussir a appliquer une css stylesheet
	-> le client envoi 2 requete GET: 
		1. pour index.html
		2. pour la page CSS
		-> pq le CSS n'est pas appliquÃ© ?!
	ğŸ‰ Ca marche c'est juste que php-cgi renvoyait html en Content-Type au lieu de css	
		-> j'ai changer de maniere moche, faudrait faire Ã§a plus propre âœ…
		-> et apres go faire un css stylÃ© ! âœ… -> y a moyen de faire un truc plus beau plus tard
!! Y a un pb avec select et je peux plus vraiment acceder au lien YOUPI, c'est bizzare...
	-> Je pense que c'etait a cause du CSS comme c'est pas un fichier html ?
	-> je l'ai enlevÃ© et Ã§a marche nickel
-> tester dans la VM puis PUSH
	-> La POST request avec le form HTML bloque sur la vm...
		-> je crois que c'est parce que le body est recu du premier coup 
			-> modifier le parsing pour s'adapter au cas oÃ¹ il y a le body avec la request / si il arrive aprÃ¨s.
		=> âœ… C'est bon ca marche go PUSH
-> reussir a faire un GET avec une image ?
	-> tout n'est pas stocker dans le body mais tout est bien recu du CGI
	- il doit y avoir une perte a un moment...
	-> Je crois que y a pas le choix il va falloir remplacer le body string en char * ğŸ˜©
	-> pour le moment juste dans CGI et response mais ca ser peut a faire dans request aussi...
		- commencer par faire un char * dans execCGI et voir si il peut stocker l'integralite des bytes

15/06/2021
!! ca bloque apres avoir envoyer un formulaire pui cliquer sur le lien Youpi... ğŸ¤”
	-> il faut reset tout les header field a chaque request ! âœ…
-> remplacer un max de malloc par des new/ delete
	-> j'en ai remplace quelques Uns
- L'erreur "In select: Bad file descriptor" arrete pas de se repeter 
	-> voir si c'est a cause des derniÃ¨res modifs (tester sur la version push)
		-> C'est pas liÃ©, il faut revoir la gestion de select !
	-> j'ai remplacer le '=' par un memcpy dans la copy des fd_set
	âœ… Ca semble resoudre le pb pour le moment...
	-> ca rebug, Ã§a viens d'ailleur ...
> reussir a faire un GET avec une image ? [SUITE]
	- commencer par faire un char * dans execCGI et voir si il peut stocker l'integralite des bytes
	-> c'est fait mnt tout est bien stocker dans un char*, il faut revoir tout le parsing
		dans Response (parser un char * au lieu d'une string)
		-> Bon alors c'est plus compliquer que ce que je pensais...
	-> Content-Length affiche des nombre negatif ???
	-> essayer de tout traiter en char * sans la gestion de l'image...
	-> Bon ca me prend la tÃªte ! on dirait que tout n'est pas bien recu par recv 
		ou c'est juste un pb avec std::cout qui n'affiche pas tout ?  -> essayer avec un write
		=> OUF c'est bon tout s'affiche bien avec write, donc tout est bien reÃ§u 
		-> par contre je crois pas que tout se concatene / stock bien dans le buf ğŸ¤”

================================== NOTES ==================================

-> reussir une request DELETE
-> faire marcher les query string
	- il faut apparement parser REFERER
-> regler le pb "In select: Bad file descriptor" => il va falloir completement revoir la gestion de select !
-> throw les bonnes exceptions aux bons endroit
-> essayer d'appliquer le CSS au php
- utiliser les routes
-> gÃ©rer l'upload de fichier (il faut passer par POST)
-> gererles leaks en cas d'erreur / d'arret

POST request from safari after HTML form:
-----------------------------------------
POST /action.php HTTP/1.1
Host: localhost:8080
Origin: http://localhost:8080
Content-Type: application/x-www-form-urlencoded
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.2 Safari/605.1.15
Referer: http://localhost:8080/
Content-Length: 18
Accept-Language: en-us
-----------------------------------------

-> comment parser le conf file ?
	-> il va fallor modifier la classe server pour qu'elle puisse stocker toutes les infos du conf file
	- probablement qu'il faudras une classe au dessus de Server pour gÃ©rer tous les serveurs

-> revoir tout les retour d'erreur dans Response
	-> on a que des 200 OK meme quand ca echoue
	-> reussir a avoir le bon retour avec le cgi

To do:
- [ ] Throw exception (ex: in getHeaderField()
- [ ] GÃ©rer les chunk request
- [ ] Recoder lâ€™appel au cgi (pour lâ€™instant câ€™est un cp de GitHub ğŸ˜¬)
- [ ] call the cgi with the file requested as first argument 
- [ ] Error pages
- [ ] truc fun a faire : remplir les fichiers de test (Youpi banane et cie)
- [ ] gerer les methodes POST et DELETE !
- [ ] revoir tout les retour d'erreur dans Response

Piste:
-> ne dÃ©finir quâ€™un server
-> commencer par juste implement GET et faire les autres mÃ©thodes aprÃ¨s (ou juste HEAD)
-> utiliser signal pour dÃ©tecter le quit du programme et bien unlink le/les sockets 
-> Faire un fichier conf de base et faire le serveur avec ses conf (voir pour stocker dans une structure ou autre) 
-> the CGI est celui qui traite la request (si chunk le serveur doit unchunk avant de lâ€™envoyer au CGI)
-> faire une classe â€˜envâ€™ avec toutes les meta-variables a passer au CGI 
-> stocker les meta-variables dans un container map âœ…


PHP_CGI
-> ont y fait appelle de la maniÃ¨re suivante:
> php-cgi index.php
> Content-type: text/html; charset=UTF-8
  <html>
   <head>
    <title>Test PHP</title>
   </head>
   <body>
   <p>Bonjour le monde</p> </body>
  </html>%


Conf file:
-> different Â«Â serverÂ Â» can be defined
-> we should be able to:
	> choose the port and host for each of them
	> choose the server name (or not)
	> setup default error pages
	> limit client body size
	> define a list of accepted HTTP methods for the routes
	> define a directory or a file from where the file should be search 	> turn on or off directory listing 	> default file to answer if the request is a directory 	> execute CGI based on certain file extension 
 
Test simple:
telnet example.com 80
HEAD /index.html HTTP/1.1
Host: example.com


- Create a directory YoupiBanane with:
	-a file name youpi.bad_extension
	-a file name youpi.bla
	-a sub directory called nop
		-a file name youpi.bad_extension in nop
		-a file name other.pouic in nop
	-a sub directory called Yeah
		-a file name not_happy.bad_extension in Yeah

Setup the configuration file as follow:
- / must answer to GET request ONLY
- /put_test/* must answer to PUT request and save files to a directory of your choice
- any file with .bla as extension must answer to POST request by calling the cgi_test executable
- /post_body must answer anything to POST request with a maxBody of 100
- /directory/ must answer to GET request and the root of it would be the repository YoupiBanane and if no file are requested, it should search for youpi.bad_extension files



Write = send avec 0 a la fin

REDIRECT_STATUS=200 REQUEST_METHOD=GET SCRIPT_FILENAME=htdocs/index.php SCRIPT_NAME=/index.php PATH_INFO=/ SERVER_NAME=site.tld SERVER_PROTOCOL=HTTP/1.1 REQUEST_URI=/nl/page HTTP_HOST=site.tld /usr/bin/php-cgi 


HTTP-message =	start-line
		*( header-field CRLF )
		CRLF
		[ message-body ]

				  Request	Response
Accept-Charsets		âœ…		  âŒ
Accept-Language		âœ…		  âŒ
Allow				âŒ		  âœ…
Authorization		âœ…		  âŒ
Content-Language	âŒ		  âœ…
Content-Length		âœ…		  âœ…
Content-Location	âŒ		  âœ…
Content-TypeÂ 		âœ…		  âœ…
DateÂ 				âœ…		  âœ…
HostÂ 				âœ…		  âŒ
Last-ModifiedÂ 		âŒ		  âœ…
LocationÂ 			âŒ		  âœ…
RefererÂ 			âœ…		  âŒ
Retry-AfterÂ 		âŒ		  âœ…
ServerÂ 				âŒ		  âœ…
Transfer-EncodingÂ 	âœ…		  âœ…
User-AgentÂ 			âœ…		  âŒ
WWW-Authenticate	âŒ		  âœ…
TOTAL				10		   12


request du tester:

GET / HTTP/1.1
Host: localhost:8080
User-Agent: Go-http-client/1.1
Accept-Encoding: gzip

POST / HTTP/1.1
Host: localhost:8080
User-Agent: Go-http-client/1.1
Transfer-Encoding: chunked
Content-Type: test/file
Accept-Encoding: gzip

0
ğŸ‘‰ devrait renvoyer une erreur car Â«Â / must answer to GET request ONLYÂ Â» (405 Method Not Allowed)

HEAD / HTTP/1.1
Host: localhost:8080
User-Agent: Go-http-client/1.1
ğŸ‘‰ devrait renvoyer une erreur car Â«Â / must answer to GET request ONLYÂ Â» (405 Method Not Allowed)

GET /directory HTTP/1.1
Host: localhost:8080
User-Agent: Go-http-client/1.1
Accept-Encoding: gzip

GET /directory/youpi.bad_extension HTTP/1.1
Host: localhost:8080
User-Agent: Go-http-client/1.1
Accept-Encoding: gzip

GET /directory/youpi.bla HTTP/1.1
Host: localhost:8080
User-Agent: Go-http-client/1.1
Accept-Encoding: gzip

GET /directory/oulalala HTTP/1.1
Host: localhost:8080
User-Agent: Go-http-client/1.1
Accept-Encoding: gzip