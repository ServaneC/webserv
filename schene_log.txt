Webserv 
(12/03/2021)

Simplification des RFC: https://docs.google.com/document/d/1_hyiqjK-wjBFPsQX040qw0_vOuAsTEjliU7gOI8rHkk/edit?usp=sharing
Fonctions: https://docs.google.com/document/d/1kAKD5ucdXaoeX5MRfoqCjVR78kADcq030BgyIGOLoUk/edit?usp=sharing

La libft n'est plus autorisé !
Authorized functions: everything in c++98
htons, htonl, ntohs, ntohl, select, poll, epoll, kqueue, socket, accept, listen, send, recv, bind, connect, inet_addr, setsockopt, getsockname, fcntl

HTTP Methods :

Minimum in a webserv:
-> GET
-> POST
-> DELETE

Vm = little endian

- [x] Lire les RFC + prendre des notes / surligner 
- [x] Faire des test avec nginx et telnet 

25/03/2021
curl -I example.com	=> Renvoi le header HTTP comme un webserver (mais marche si Nginx ne run pas)
curl -I 'localhost'		=> ne marche que si Nginx run 
✅ Makefile fait + libft dans le dossier
-> prise de notes sur les nouvelles fonctions 

29/03/2021
-> création d’une classe server
-> essai de faire un server fonctionnel très très simplifié
	> class Server
	> class Request

30/03/2021
- [x] Trier les req. Header / response Header 
- [x] Faire un map stockant toutes les valeurs des request header field possible
- [x] Parse request (manque le message body) -> pas utile pour GET
-> début du setup du CGI (env)

01/04/2021
- [x] Faire un simple cgi qui ouvre et renvoi un simple fichier html
- [x] Faire un .hpp avec tout les includes commun = plus propre

02/03/2021
- [x] Envoyer la réponse au socket 
- [x] Faire marcher dans la vm !!!
-> safari dit que la demande est en HTPP/0.9 ?!
-> j’ai écrit les header fields de la réponse sur cout au lieu du socket 🙄
- [x] pouvoir la visualiser dans le moteur de recherche (mac + VM 🎉)
-> to format the date we have gettimeofday(), strftime() and strptime()-> we should probably ignore  strptime()
- [x] Gérer date avec les fonctions appropriés ‼️ Utilisation de gmtime (fonction apparement non autorisé)

05/04/2021
- [x] Mettre la request dans un fichier a part et le client lit le fichier puis envoie la request (= plus facilement modifiable)
- [x] Gérer le last-modified
- [x] Faire une fonction pour formater les dates 
—> sur la vm la request arrives vide au server 
- [x] Faire marcher dans la vm ! (C’est chelou quand même)

06/04/2021
- [x] Mettre sur github
- [x] Faire un page index.html
- [x] Gérer les target avec ‘/‘ (absolut path)

07/04/2021
- [x] Faire un test simple faisant appelle a php-cgi 
- [x] Réussir a appeler php-cgi et avoir un retour avec execve
—> ca marche pas de ouf, la réponse n’arrives pas, ca bloque apparement a un endroit
(J’avais oublié d’appeler la fonctions execCGI 🤦🏻‍♀️ )


08/04/2021
- [x] Trouver un cgi qui marche pour autre chose que php et surtout pour mac  => CGI dans les ressources !!!
- [x] Tester les cgi des ressources 
-> le cgi_tester marche avec execve mais ne renvois rien 
-> le cgi tourne dans le vide… 💀
👉 on se re-concentre sur php-cgi
- [x] Faire marcher php-cgi avec notre WebServ
-> ça affiche aussi le header field dans le web but on verra ca plus tard !
👉 Plus le choix faut réussir a faire marcher cgi_tester !
->execve crash avec cgi_tester 
- [x] Faire marcher cgi_tester avec execve (meme si retour pas bon)
🤦🏻‍♀️ a.out était dans srcs et donc pas dans le meme repo que cgi_tester et index.html
- [x] Comprendre comment bien appeler cgi_tester
😕 Il n’y a pas de body dans la réponse du cgi…

09/04/21
- [x] Essayer de passer le file en argument du cgi -> voir si le body apparait
-> le body apparait pas …
- [x] Retrouver ce qui marchait avec php-cgi parce que la ca marche plus lol
🤦🏻‍♀️ J’avais mis HEAD en méthode dans le test.cpp donc forcement y avait plus le body 
😩 Le cgi_tester ne renvois toujours pas de body !
- [x] Bosser sur le repo git !
-> on verra le body plus tard, je tourne en rond !
-> php-cgi renvoie en header field puis un \n et le body
- [x] Parser le header field renvoyé par le cgi
	-> ca marche pour le header renvoyé par cgi_tester (sans body du coup) mais ca diminue le fichier dans la vm avec php-cgi
	-> il y avais un souci car php-cgi renvoi un header ‘Content-type’ au lieu de ‘Content-Type’  (j’ai régler le souci de manière un peu moche)
    - [x] Arriver a arrêter le parsing a la fin des headers fields. 
		-> j’essayais de trouver un \n en début de ligne pour arrêter mais c’était un \r qu’il y avait (CRLF = \r\n)
	👉 Ca marche aussi avec un 404 (on récupère le bon status)

12/04/2021
-> ajout des CRLF (\r\n)  au lieu de juste \n dans la réponse HTTP
- [x] Réorganiser toutes les fonctions => diviser les gros blocs
	-> J’ai créer une fonction send_response (qui imprime les header_fields dans une boucle)
	=> réorganisation faite pour Response
- [x] Deux \n entre header et body dans la response ? -> le \n est deja dans le body
- [x] Utilisation de select pour read

14/04/2021
-> J’ai mis tout les .hpp dans un dossier include dans les srcs
-> J’ai fait un dossier test_dir avec tout les fichier test = c’est un peu moins le bordel 
‼️ T=� 1 fois sur deux en fin de réponse ?
	-> J’ai bien terminer le buf avec un 0 au lieu de juste le ft_memcpy
- [x] Gérer les leak avec -fsanitize=address
    - [x] Memory access after free dans le response destructor
	-> juste un clear au lieu dans erase en boucle + clear
- [x] Parse la request au CRLF et pas juste \n
- [x] Parse url of type ->  http://localhost:80/
    - [x] Améliorer le parsing de la request line
	-> ajout d’une fonction ParseRequestLine
=> PUSH GitHub

15/04/2021
-> Réglage du décalage horaire (+ 2h)		 / / je viens du futur, c’etait inutile !
- [x] Gérer les OWS dans le parsing des header field de la request


20/04/2021
- [x] Modifier ce qu’il faut  car mnt on peut utiliser  ctime  et cstring
	-> time() au lieu de gettimeofday() = +simple (j’ai enlever le réglage du décalage horaire car GMT n’est pas sensé être l’heure exacte en France)
	-> gmtime() est mnt autorisé
    - [x] utiliser cstring plutôt que la libft
- [x] Utiliser des ref sur string dans les getter
	-> j’ai mis search_header en private (dans response)
- [x] Voir pour utiliser getline() au lieu de gnl
	-> ca semble compliqué il faudrait ouvrir le file avec fstream mais c’est pas autorisé…
	-> peut être lire tout le file dans un buf puis créer une stream sur le buf ? ->semble pas très optimal
	-> voir pour lire le socket dans server.cpp et ensuite l’envoyé a request.cpp qui parsera le tout -> on pourra se débarrasser de gnl
	=> on continue avec gnl pour le moment a voir si ils autorisent fstream a l’avenir…
- [x] Mieux comprendre le conf file et ce qu’il fait exactement

21/04/2021
👉 avec php-cgi ubuntu_tester renvoi « FATAL ERROR ON LAST TEST: unexpected EOF » au premier test
	-> pourquoi ?!
	-> overflow dans gnl apres plusieur lancement du tester  // on verra plus tard
    - [x] ajouter un CRLF a la fin du body. // je viens du futur et fallais pas faire ca 
	🎉 Passage du premier test avec php-cgi (le pb venais juste du CRLF)
	—> je passe apparement le test POST (j’ai fait en sorte qu’il renvoi une erreur mais de maniere tres moche pour le moment) 
		-> ca marche pas tout le temps…
- [x] faire une GET method pas ouf et voir si on passe le premier test
👉 J’ai fait une fonction  execGET mais elle semble pas parfaite et a retravailler…
- [x] mieux gérer les CRLF entre les header et le body et a la fin si y a pas de body.
📝 J’aurais apparement eu raison au début en créant moi meme la reponse a GET, je crois que le CGI est a utiliser seulement pour certaine méthodes
Sur mac: 2eme test
	Test POST http://localhost:8080/ with a size of 0
	2021/04/21 20:02:11 Unsolicited response received on idle HTTP channel starting with "\r\n"; err=<nil>
✅ Ca marche ! 👉 il ne faut pas mettre de CRLF apres le message-body (juste entre header et body/fin)
Pour le moment GET ignore le path et ouvre juste index.html

22/04/2021
- [x] faire ouvrir le bon path / renvoyer le bon message d’erreur pour GET
Abort apres plusieur refresh et un client en not found 
	✅ Résolu: création d’une fonction free_buf appelle dans response (a revoir pour quelque chose de plus propre)
- [x] pb avec last modified (indique 1970)
	👉 Ajout d’un getter last-modified dans myCGI

23/04/2021
Tester dans la VM:
-> probleme de parsing, un buf doit etre mal vidé ou autre… ca fait des trucs chelou
-> peut etre une erreur avec write ? (write: broken pipe)
👉 C’est chelou le premier test marche mais les autres passe une fois sur 3
Tester mac:
✅ Les trois premiers test passe a chaque fois sans pb (c’est normal j’ai pas géré la réponse du 4ème)
‼️ Le 2ème et 3ème je renvois juste l’erreur qu’il veut c ‘est pas pro et ca passerais pas c’est complètement a revoir 

🤦🏻‍♀️ Nouveau problème le tester bloque a POST (2eme test)
-> les meme test en passant par client ne bloques pas
🙄 Régler j’avais oublié de close le socket (je l’avais commenté pour tester un truc vite fait)

- [x] gérer le body dans request
	-> c’est géré faudrait juste bien check qu’il y a le CRLF avant et ca sera parfait 
	+ faire une ( ou 2 ) fonction(s) en plus pour alleger parseRequest()
👉 essayer de passer les trois premiers test sur la VM
	-> POST =  read: connection reset by peer / write: broken pipe
	-> ca vient peut etre de gnl 🤔
	-> des fois tout passe et des fois ca bloque a POST… 😡


27/04/2021
- [x] mettre dans une fonction a part le parsing des headers field dans request
	+ ajout d’une fonction free_null_line
- [x] essayer de créer un container docker pour tester avec nginx
	-> j’ai juste lancer un container sur la vm et j’ai pu envoyer un GET mais faudrait faire bcppppp plus de test
- [x] améliorer le check si CRLF dans request 
- [x] ‘use the parsed data to determine if a message body is expected’ 👉 Le parsing du body est peut être a revoir 
	👉 Content-Lenght ou transfer encoding = message body
	✅ C ‘est fait mais pas testé
🤦🏻‍♀️ Leaks gnl  avec le testeur dans la vm (mais rien sur mac) (dans parseRequest)
- [x] bien check la request et renvoyé erreur si incorrect
    - [x] renvoyé la bonne réponse si pas de CRLF (bad Request je crois) -> actuellement c’est juste un perror tout pourri et un exit
		✅  + si space entre field-name et colon = renvoi un 400 bad request
		👉 peut être a revoir pour mieux gérer mais ca marche 

28/04/2021
- [x] résoudre la leak dans parse request (sur vm)
	🤷🏻‍♀️ Je la retrouve pas, j’ai du la résoudre sans faire exprès
👉 Pour le moment les test bug parfais dans la vm et parfois passent, ca vient peut etre du select ? Je verrais plus tard…
	👉 En tout cas les trois premier passent a chaque fois sans pb sur mac
- [x] mieux gérer les erreurs possible dans le parsing de la request line
    - [x] accepter tout les ws pas just sp comme séparateur 
		👉MAY instead parse on whitespace-delimited word boundaries 
		👉 C’est pas obligatoire a géré ❌
    - [x] renvoyer un bad request si plus que 1 ws entre item

30/04/2021
👉 Création de la classe config qui serviras a mettres les infos du conf file
    - [x] lire le file dans une string

03/05/2021
pistes pour le parsing:
	-> split tout les server {} puis les traiter chacun dans une autre classe
	-> Avoir une classe config de base avec un vector de pointeur sur les différents serveurs
	-> Dans la classe confServer:
		- server_name
		- map des routes -> peut etres il faut une class config pour les routes aussi (pour stocker les accepteds method et autre
			-> un map<string, ConfigRoute> peut-être avec dans configRoute
				- root =  a directory or a file from where the file should be search 
				- Vector ou list des méthodes acceptés
				- default file to answer if the request is a directory 
				- client body size
		-  bool pour  « turn on or off directory list »		- limit client body size
		- map avec les error pages 
		- host:port

04/05/2021
- [ ] Comprendre ce que fait chaque méthodes -> écrire une explication avec exemple pour chaque 
- [x] tester la méthode DELETE avec le cgi_tester -> bad request

06/05/2021
- [x] modifier le client pour qu’il ajoute le CRLF entre les headers et le body/la fin
	-> c’est fait mais mnt le serveur capte plus rien 
    - [x] re tester avec le tester -> Ca marche ✅
	-> le serveur ne lit pas la request en entier… pourquoi ?
	-> Je suis revenu a comme avant faut que j’essaye autre chose
	-> j’ai tenté autre chose mais mnt j’ai un segfault dans le parserequest 🤦🏻‍♀️
	-> Abandon …
- [x] Au lieu de check si CRLF entre header et body -> check si CRLF ou juste LF
- [x] retester DELETE avec cgi_tester -> ca marche pas j’ai peut etre pas compris DELETE
- [x] tester dans la vm avec php-cgi
	-> la réponse a un body alors qu’elle ne devrait pas 

‼️ On dirait que le parsing du header du cgi ne marche plus 🤔
    - [x] revoir la fonction parse_cgi_buf()
	✅ Résolu -> je returnais si le buf n’étais pas empty donc forcément ca returnais a chaque fois… 🙄

01/06/2021 (NEW SUBJECT !)
- [x] comprendre ce qu'est 'poll' => variation de select ( a voir si c'est mieux)
- [x] modifier le code afin de ne plus utiliser la libft
	-> ft_isspace -> isspace
	-> ! PB: gnl n'est plus utilisable, il faut donc revoir tout les appels a gnl
	-> il faut surement remplacer par l'utilisation des streams
	-> pb: stream ne marche pas sur les fd, il faut probablement lire toutes la requete et ensuite la parser

03/06/2021 
!! ERREUR "In select: Bad file descriptor" sur le mac de l'ecole avec localhost:8080" dans google chrome
	-> en revanche sa marche avec safari... 
- [x] parser la request sans utiliser gnl
	-> je lis la request avec recv 
	-> il faut mnt la transformer en string puis la parser. 
		- [x] recu et transformer en string 
		!! pb: les request s'empilent au lieu de s'effacer => clear a la fin de parseRequest
		- [x] parser la request
		✅ Ça marche comme avec gnl !! 
- [x] enlever la libft
	-> pb avec itoa dans response (j'ai commenter en attendant de trouver mieux)
	-> pb avec strdup dans myCGI (env_to_char_array), j'ai fait un mini strdup pas ouf dans la fonction


04/06/2021 
- [x] tester dans la vm -> ça marche tres bien
- [x] voir pour remplacer ou faire autrement pour itoa
	-> creation de la foncton itoa_cpp qui utilise une stream
- [x] modifier le env to char array -> en fait c'est pas si mal
- [>] remplacer select par poll
	-> poll est plus performant que select (et il a l'air plus simple a comprendre)
	-> epoll pourrait aussi être  interessant mais c'est specifique a linux
	=> A faire apres le parsing du conf file quandd on aura plusieurs server a gérer
- [x] faire un conf file pour ensuite le parser -> webserv.conf

07/06/2021 
-> j'ai modifié + bouger client.cpp (parce que en vrai il avait rien a faire dans les srcs) => directory client
-> le cgi est php-cgi et marche aussi sur mac 
	-> j'ai testé avec GET ca marche nickel
		=> Du coup j'ai supprimé la fonction execGET
	-> j'ai fait quelque test pour POST mais je comprend pas grand chose et du coup ca marche pas
	-> j'ai l'impression que quelque soit la méthode ca repond comme un GET
LEILA:
	=> modification de config et debut du parsing du conf file
	=> modif dans main -> appel a config et non Server 


08/06/2021 	
(dire a leila d'ecrire dans log / se faire un log a elle)
-> voir comment gere les locations (maybe faire une classe / struct pour stocker les infos)
	=> class is better bc we are in C++
-> verifier ce qu'a fait leila puis merge
	!! pas de merge tant que c'est pas fonctionnel
	-> revoir completement start_server
-> bon alors j'ai modifie plein de trucs et ca marche pas de ouf ca arrive a repondre a une requete avant de abort...
=> je bosse (enfin) sur ma branche git je peux donc faire toutes les modifs que je veux tranquillou
-> il va surement falloir changer de CGI parceque php-cgi marche pas sur les macs de l'ecole 
	=> ou peut etre qu'il faut mettre l'executable php-cgi dans les sources ? ✅
-> ca marche exactement comme avant avec un seul server dans le conf file
	-> la gestion de plusieurs serveur est donc a revoir 
	-> en profiter pour remplacer select par poll
		=> poll est trop prise de tete et ca marche pas 
->pb avec les dates dans reponses (last modified a revoir)
	-> comme on passe par le cgi on a pas direct acces au fichier pour faire un fstat
		=> On oublie Last-Modified pour le moment

10/06/2021 	
-> il faut absolument merge a un moment les branches vers master sinon ca va devenir un casse tête !
	a faire avant:
		-> reussir a bien gerer plusieurs "server"
			- bon j'ai retenté de remplacer select par poll mais ca fait que bloquer donc je pense completement abbandonne cette piste
✅ Tout est merge ! bon par contre j'ai quelque soucis pour acceder aux adresse ip autre que localhost:8081 avec le webserv.conf de leila...
-> l'executable de php-cgi ne suffit pas a le faire marcher quand php n'est pas installé sur un ordi ...
	-> On va surement etre oblige de demander a installer php

11/06/2021
-> Il y a 2 champs Content-Type dans le header de reponse -> le compare etait mal fait mais c'est regle 
	-> header 'X-Powered-By'  ? _> c'est un header non standard qu'il est recommande d'enlever, j'ai rajouter un if qui ne stocke pas le header si il commence par 'X'
-> le CGI est mnt appelé avec le file en argument (comme demandé dans le sujet mais je sais pas ce que ca change)
-> reussir a accéder a un fichier autre que index.html avec le cgi
	-> on peut mais a chaque lancement de webserv on ne peut plus changer le path du fichier auquel on veut accéder, pourquoi ???
-> reussir a lire le body d'une request
	✅ Il fallait parser le header, trouver Content-Lenght puis recv en boucle jusqu'a recevoir le body !
-> trouver comment passer les infos du body au cgi !!!

13/06/2021
-> il audrait merge aujourd'hui (max demain), avant j'aimerais bien:
	(au moins un des 4)
	✅ -> reussir a acceder a differentes pages
		- je pense que c'est lie a un buf/ une string qui ne se renouvelle pas
			- l'heure change bien dans Date de response
			-> remplacer le buf std:string en char * dans response => revoir tout le parsing du buf !
			-> j'ai fait plein de modif et au final j'ai garder la forme std::string (qu'il faudra peut etre modifier plus tard) et...
			=> Ça marche !!!! on peut acceder a plein de page diférentes avec un seul lancement de webserv 🎉
-> avant de push + merge, tout tester surla vm ! ✅
-> ameliorer la gestion des 400 bad request (y a un segfault actuellement) -> plus de segfault
	- renvoyer 405 method not allowed si autre que methode autorise
	
14/06/2021
-> reussir une request POST
	🎉 Ca marche avec le formulaire HTML dans index ! (fallait juste faire un write sur stdin avant le fork)
	!! Ca marche une seule fois -> surement encore un pb de buf qui se renouvelle pas ?
		✅ C'etait bien ca le pb j'ai ajouté un clear avant de lire le body dans Request.
-> reussir a appliquer une css stylesheet
	-> le client envoi 2 requete GET: 
		1. pour index.html
		2. pour la page CSS
		-> pq le CSS n'est pas appliqué ?!
	🎉 Ca marche c'est juste que php-cgi renvoyait html en Content-Type au lieu de css	
		-> j'ai changer de maniere moche, faudrait faire ça plus propre ✅
		-> et apres go faire un css stylé ! ✅ -> y a moyen de faire un truc plus beau plus tard
!! Y a un pb avec select et je peux plus vraiment acceder au lien YOUPI, c'est bizzare...
	-> Je pense que c'etait a cause du CSS comme c'est pas un fichier html ?
	-> je l'ai enlevé et ça marche nickel
-> tester dans la VM puis PUSH
	-> La POST request avec le form HTML bloque sur la vm...
		-> je crois que c'est parce que le body est recu du premier coup 
			-> modifier le parsing pour s'adapter au cas où il y a le body avec la request / si il arrive après.
		=> ✅ C'est bon ca marche go PUSH
-> reussir a faire un GET avec une image ?
	-> tout n'est pas stocker dans le body mais tout est bien recu du CGI
	- il doit y avoir une perte a un moment...
	-> Je crois que y a pas le choix il va falloir remplacer le body string en char * 😩
	-> pour le moment juste dans CGI et response mais ca ser peut a faire dans request aussi...
		- commencer par faire un char * dans execCGI et voir si il peut stocker l'integralite des bytes

15/06/2021
!! ca bloque apres avoir envoyer un formulaire pui cliquer sur le lien Youpi... 🤔
	-> il faut reset tout les header field a chaque request ! ✅
-> remplacer un max de malloc par des new/ delete
	-> j'en ai remplace quelques Uns
- L'erreur "In select: Bad file descriptor" arrete pas de se repeter 
	-> voir si c'est a cause des dernières modifs (tester sur la version push)
		-> C'est pas lié, il faut revoir la gestion de select !
	-> j'ai remplacer le '=' par un memcpy dans la copy des fd_set
	✅ Ca semble resoudre le pb pour le moment...
	-> ca rebug, ça viens d'ailleur ...
> reussir a faire un GET avec une image ? [SUITE]
	- commencer par faire un char * dans execCGI et voir si il peut stocker l'integralite des bytes
	-> c'est fait mnt tout est bien stocker dans un char*, il faut revoir tout le parsing
		dans Response (parser un char * au lieu d'une string)
		-> Bon alors c'est plus compliquer que ce que je pensais...
	-> Content-Length affiche des nombre negatif ???
	-> essayer de tout traiter en char * sans la gestion de l'image...
	-> Bon ca me prend la tête ! on dirait que tout n'est pas bien recu par recv 
		ou c'est juste un pb avec std::cout qui n'affiche pas tout ?  -> essayer avec un write
		=> OUF c'est bon tout s'affiche bien avec write, donc tout est bien reçu 
		-> par contre je crois pas que tout se concatene / stock bien dans le buf 🤔

================================== NOTES ==================================

-> reussir une request DELETE
-> faire marcher les query string
	- il faut apparement parser REFERER
-> regler le pb "In select: Bad file descriptor" => il va falloir completement revoir la gestion de select !
-> throw les bonnes exceptions aux bons endroit
-> essayer d'appliquer le CSS au php
- utiliser les routes
-> gérer l'upload de fichier (il faut passer par POST)
-> gererles leaks en cas d'erreur / d'arret

POST request from safari after HTML form:
-----------------------------------------
POST /action.php HTTP/1.1
Host: localhost:8080
Origin: http://localhost:8080
Content-Type: application/x-www-form-urlencoded
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.2 Safari/605.1.15
Referer: http://localhost:8080/
Content-Length: 18
Accept-Language: en-us
-----------------------------------------

-> comment parser le conf file ?
	-> il va fallor modifier la classe server pour qu'elle puisse stocker toutes les infos du conf file
	- probablement qu'il faudras une classe au dessus de Server pour gérer tous les serveurs

-> revoir tout les retour d'erreur dans Response
	-> on a que des 200 OK meme quand ca echoue
	-> reussir a avoir le bon retour avec le cgi

To do:
- [ ] Throw exception (ex: in getHeaderField()
- [ ] Gérer les chunk request
- [ ] Recoder l’appel au cgi (pour l’instant c’est un cp de GitHub 😬)
- [ ] call the cgi with the file requested as first argument 
- [ ] Error pages
- [ ] truc fun a faire : remplir les fichiers de test (Youpi banane et cie)
- [ ] gerer les methodes POST et DELETE !
- [ ] revoir tout les retour d'erreur dans Response

Piste:
-> ne définir qu’un server
-> commencer par juste implement GET et faire les autres méthodes après (ou juste HEAD)
-> utiliser signal pour détecter le quit du programme et bien unlink le/les sockets 
-> Faire un fichier conf de base et faire le serveur avec ses conf (voir pour stocker dans une structure ou autre) 
-> the CGI est celui qui traite la request (si chunk le serveur doit unchunk avant de l’envoyer au CGI)
-> faire une classe ‘env’ avec toutes les meta-variables a passer au CGI 
-> stocker les meta-variables dans un container map ✅


PHP_CGI
-> ont y fait appelle de la manière suivante:
> php-cgi index.php
> Content-type: text/html; charset=UTF-8
  <html>
   <head>
    <title>Test PHP</title>
   </head>
   <body>
   <p>Bonjour le monde</p> </body>
  </html>%


Conf file:
-> different « server » can be defined
-> we should be able to:
	> choose the port and host for each of them
	> choose the server name (or not)
	> setup default error pages
	> limit client body size
	> define a list of accepted HTTP methods for the routes
	> define a directory or a file from where the file should be search 	> turn on or off directory listing 	> default file to answer if the request is a directory 	> execute CGI based on certain file extension 
 
Test simple:
telnet example.com 80
HEAD /index.html HTTP/1.1
Host: example.com


- Create a directory YoupiBanane with:
	-a file name youpi.bad_extension
	-a file name youpi.bla
	-a sub directory called nop
		-a file name youpi.bad_extension in nop
		-a file name other.pouic in nop
	-a sub directory called Yeah
		-a file name not_happy.bad_extension in Yeah

Setup the configuration file as follow:
- / must answer to GET request ONLY
- /put_test/* must answer to PUT request and save files to a directory of your choice
- any file with .bla as extension must answer to POST request by calling the cgi_test executable
- /post_body must answer anything to POST request with a maxBody of 100
- /directory/ must answer to GET request and the root of it would be the repository YoupiBanane and if no file are requested, it should search for youpi.bad_extension files



Write = send avec 0 a la fin

REDIRECT_STATUS=200 REQUEST_METHOD=GET SCRIPT_FILENAME=htdocs/index.php SCRIPT_NAME=/index.php PATH_INFO=/ SERVER_NAME=site.tld SERVER_PROTOCOL=HTTP/1.1 REQUEST_URI=/nl/page HTTP_HOST=site.tld /usr/bin/php-cgi 


HTTP-message =	start-line
		*( header-field CRLF )
		CRLF
		[ message-body ]

				  Request	Response
Accept-Charsets		✅		  ❌
Accept-Language		✅		  ❌
Allow				❌		  ✅
Authorization		✅		  ❌
Content-Language	❌		  ✅
Content-Length		✅		  ✅
Content-Location	❌		  ✅
Content-Type 		✅		  ✅
Date 				✅		  ✅
Host 				✅		  ❌
Last-Modified 		❌		  ✅
Location 			❌		  ✅
Referer 			✅		  ❌
Retry-After 		❌		  ✅
Server 				❌		  ✅
Transfer-Encoding 	✅		  ✅
User-Agent 			✅		  ❌
WWW-Authenticate	❌		  ✅
TOTAL				10		   12


request du tester:

GET / HTTP/1.1
Host: localhost:8080
User-Agent: Go-http-client/1.1
Accept-Encoding: gzip

POST / HTTP/1.1
Host: localhost:8080
User-Agent: Go-http-client/1.1
Transfer-Encoding: chunked
Content-Type: test/file
Accept-Encoding: gzip

0
👉 devrait renvoyer une erreur car « / must answer to GET request ONLY » (405 Method Not Allowed)

HEAD / HTTP/1.1
Host: localhost:8080
User-Agent: Go-http-client/1.1
👉 devrait renvoyer une erreur car « / must answer to GET request ONLY » (405 Method Not Allowed)

GET /directory HTTP/1.1
Host: localhost:8080
User-Agent: Go-http-client/1.1
Accept-Encoding: gzip

GET /directory/youpi.bad_extension HTTP/1.1
Host: localhost:8080
User-Agent: Go-http-client/1.1
Accept-Encoding: gzip

GET /directory/youpi.bla HTTP/1.1
Host: localhost:8080
User-Agent: Go-http-client/1.1
Accept-Encoding: gzip

GET /directory/oulalala HTTP/1.1
Host: localhost:8080
User-Agent: Go-http-client/1.1
Accept-Encoding: gzip